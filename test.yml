2022-02-15 00:00:00:
- q: Certain objects such as the model above should not be serialized. Why?
  a: serializing objects that encapsulate local machine state may not / probably are
    not meaningful for remote machines. Also, the time that it takes for them to be
    transferred may mean that they will be out of date by the time they make it to
    other machines
- q: Special errors that arise when accessing a distributed queue, which would not
    occur when accessing a local queue?
  a: lack of synchronization between multiple remote accessors could lead to possible
    loss of data.
- q: What do the terms "Remote Assignment (data communication)" and "Remote procedure
    call" mean?
  a: both of these are remote analogues for their local counterparts. Remote assignment
    involves transferring data from a source machine to a destination to assign it
    to some location on the destination machine. A remote procedure call involves
    a machine sending a method call with argument data to another machine which runs
    a procedure and (possibly) returns result data to the first machine.
- q: Steps in a remote procedure call? Take the examples of counter increment() and
    getValue(). Assume the method that calls the remote method (e.g. producer or consumer)
    loop is on the stack.
  a: A remote procedure call would be wrapped by a local call to invoke the remote
    mechanism. Its activation record would contain the location of the remote machine,
    the method signature, arguments (non-atomic args would be serialized), and other
    information. Then the calling machine would wait for a response to come over the
    network, which it would return to the local call (or handle a network or any other
    error appropriately).
2022-02-17 00:00:00:
- q: Why is this (not) consistent with the try catch block? Why and what should we
    do about the problem?
  a: the counter interface should propagate potential remote errors by throwing a
    RemoteException in its method signatures.
- q: How does calling process name a remote object and get a proxy object for it?
    How does a callee process ensure that only certain instances of a remote class
    are remote objects for which proxies are obtained?
  a: to name and obtain a reference to a remote object, the calling process must either
    have some knowledge of the location and name of the object or must use an independent
    registry to look up the information, which it can then use to build a proxy object.
    The callee can control which instances are handed out to remote machines via telling
    them about the object (making them [in]visible)
2022-02-22 00:00:00:
- q: 'What is wrong with this approach of symmetric exports? Hint: Think awareness.
    Do not solve problem this is the next question.'
  a: there is duplication of proxy data
- q: 'How to get proxies in both processes using one-way awareness? Hint: Rules for
    parameter passing are the same for rmi registry calls and target object calls.'
  a: we can mediate observer/observable functionality using the proxies stored in
    the registry
- q: 'Why does Java not like the fact that the signatures in the subtype throw checked
    exception while the matching signatures in the super type do not? Hint: what will
    happen if the variable counter is typed using Counter instead of DistributedCounter?'
  a: The supertype Counter will not require checking for RemoteExceptions that may
    be thrown from RMI.
- q: What kind of error will occur with this statement? Compile time and/or runtime?
  a: A compile time error will occur since we attempt to cast the proxy returned from
    the rmiRegistry lookup to a Counter, which is not distributable
2022-02-24 00:00:00:
- q: Output?
  a: true true 0 true
- q: Output?
  a: false false false
- q: 'Why are the (inherited) methods getValue() and increment() forwared to the remote
    object but not the methods equals() and toString(). What is different? Hint: Look
    at the interface of ADistributedCounter'
  a: since the methods getValue() and increment() each throw a RemoteException, the
    compiler can infer that they are meant to be used remotely and so the proxy will
    forward calls to those methods to the remote object
- q: 'Try to explain why getRegistry() succeeded and lookup() failed when the name
    server was missing. Hint: Think of bootstrapping, the state stored in a proxy,
    and when remote messages need to be sent.'
  a: the getRegistry() call does not actually make the local machine to communicate
    with the registry, it simply initializes the fields that are used to do so. Next,
    when lookup is called, the machine actually tries and fails to reach the remote
    registry, throwing the error.
2022-03-01 00:00:00:
- q: Can a client and server increments interfere with each other? Can increments
    of two different clients interfere with each other? State your assumptions regarding
    the threads that handle incoming remote calls.
  a: I will assume that the increment calls on both client machines will be handled
    serially in one RMI thread on the server, meaning that there will be two threads
    calling increment() concurrently. But if two or more threads are calling concurrently,
    it doesn't matter because the increment operation is additive and the result will
    not change regardless of operation order. Thus, it doesn't matter to us unless
    there are calls to other methods that depend on ordered operation.
- q: 'Pros and cons of creating a single thread for all remote calls? (Hint: think
    programming effort, correctness, reuse, performance)'
  a: A single thread that exists for the lifetime of the program reduces overhead
    of thread initialization and program complexity. However, it can suffer in performance
    if unable to take advantage of possible gains from multithreading.
- q: 'Pros and cons of creating a new thread for each remote call, assuming you want
    multiple threads? (Hint: think remote calls with low and high execution times)'
  a: New threads for each remote call could yield performance benefits for long-running
    methods, but come with the cost of initialization overhead which could outweigh
    the performance gains in short-running processes. Multithreading also yields challenges
    with concurrency of course
- q: 'Some intermediate scheme between creating a single thread for all calls and
    a seperate thread per call that will provide efficient concurrency even when a
    single remote object is exported by a process? (So providing a seperate thread
    for each remote object is not an option) Hint: Think how the reduction step is
    parallelized in A2 (and A3)'
  a: We could create some sort of RMI executor thread pool that executes remote methods
    according to some sort of schedule (e.g. round robin) or by method (assign long-running
    methods to some thread, short-running methods to another, etc)
2022-03-03 00:00:00: []
