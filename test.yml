2022-02-15 00:00:00:
- q: Certain objects such as the model above should not be serialized. Why?
  a: serializing objects that encapsulate local machine state may not / probably are
    not meaningful for remote machines. Also, the time that it takes for them to be
    transferred may mean that they will be out of date by the time they make it to
    other machines
- q: Special errors that arise when accessing a distributed queue, which would not
    occur when accessing a local queue?
  a: lack of synchronization between multiple remote accessors could lead to possible
    loss of data.
- q: What do the terms "Remote Assignment (data communication)" and "Remote procedure
    call" mean?
  a: both of these are remote analogues for their local counterparts. Remote assignment
    involves transferring data from a source machine to a destination to assign it
    to some location on the destination machine. A remote procedure call involves
    a machine sending a method call with argument data to another machine which runs
    a procedure and (possibly) returns result data to the first machine.
- q: Steps in a remote procedure call? Take the examples of counter increment() and
    getValue(). Assume the method that calls the remote method (e.g. producer or consumer)
    loop is on the stack.
  a: A remote procedure call would be wrapped by a local call to invoke the remote
    mechanism. Its activation record would contain the location of the remote machine,
    the method signature, arguments (non-atomic args would be serialized), and other
    information. Then the calling machine would wait for a response to come over the
    network, which it would return to the local call (or handle a network or any other
    error appropriately).
2022-02-17 00:00:00:
- q: Why is this (not) consistent with the try catch block? Why and what should we
    do about the problem?
  a: the counter interface should propagate potential remote errors by throwing a
    RemoteException in its method signatures.
- q: How does calling process name a remote object and get a proxy object for it?
    How does a callee process ensure that only certain instances of a remote class
    are remote objects for which proxies are obtained?
  a: to name and obtain a reference to a remote object, the calling process must either
    have some knowledge of the location and name of the object or must use an independent
    registry to look up the information, which it can then use to build a proxy object.
    The callee can control which instances are handed out to remote machines via telling
    them about the object (making them [in]visible)
2022-02-22 00:00:00:
- q: 'What is wrong with this approach of symmetric exports? Hint: Think awareness.
    Do not solve problem this is the next question.'
  a: there is duplication of proxy data
- q: 'How to get proxies in both processes using one-way awareness? Hint: Rules for
    parameter passing are the same for rmi registry calls and target object calls.'
  a: we can mediate observer/observable functionality using the proxies stored in
    the registry
- q: 'Why does Java not like the fact that the signatures in the subtype throw checked
    exception while the matching signatures in the super type do not? Hint: what will
    happen if the variable counter is typed using Counter instead of DistributedCounter?'
  a: The supertype Counter will not require checking for RemoteExceptions that may
    be thrown from RMI.
- q: What kind of error will occur with this statement? Compile time and/or runtime?
  a: A compile time error will occur since we attempt to cast the proxy returned from
    the rmiRegistry lookup to a Counter, which is not distributable
